/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Cypher from "@neo4j/cypher-builder";
import type { ResolveTree } from "graphql-parse-resolve-info";
import type { AttributeAdapter } from "../../../../schema-model/attribute/model-adapters/AttributeAdapter";
import type { ConcreteEntityAdapter } from "../../../../schema-model/entity/model-adapters/ConcreteEntityAdapter";
import type { InterfaceEntityAdapter } from "../../../../schema-model/entity/model-adapters/InterfaceEntityAdapter";
import type { RelationshipAdapter } from "../../../../schema-model/relationship/model-adapters/RelationshipAdapter";
import type { Neo4jGraphQLTranslationContext } from "../../../../types/neo4j-graphql-translation-context";
import { asArray } from "../../../../utils/utils";
import { OperationField } from "../../ast/fields/OperationField";
import { MutationOperationField } from "../../ast/input-fields/MutationOperationField";
import { ParamInputField } from "../../ast/input-fields/ParamInputField";
import { PropertyInputField } from "../../ast/input-fields/PropertyInputField";
import { CreateOperation } from "../../ast/operations/CreateOperation";
import type { ReadOperation } from "../../ast/operations/ReadOperation";
import { TopLevelCreateMutationOperation } from "../../ast/operations/TopLevelCreateMutationOperation";
import { UnwindCreateOperation } from "../../ast/operations/UnwindCreateOperation";
import type { UpdateOperation } from "../../ast/operations/UpdateOperation";
import { NodeSelectionPattern } from "../../ast/selection/SelectionPattern/NodeSelectionPattern";
import { RelationshipSelectionPattern } from "../../ast/selection/SelectionPattern/RelationshipSelectionPattern";
import type { CallbackBucket } from "../../utils/callback-bucket";
import { assertIsConcreteEntity, isConcreteEntity } from "../../utils/is-concrete-entity";
import { isUnionEntity } from "../../utils/is-union-entity";
import { raiseAttributeAmbiguity } from "../../utils/raise-attribute-ambiguity";
import type { QueryASTFactory } from "../QueryASTFactory";
import { getAutogeneratedFields } from "../parsers/get-autogenerated-fields";

export class CreateFactory {
    private queryASTFactory: QueryASTFactory;

    constructor(queryASTFactory: QueryASTFactory) {
        this.queryASTFactory = queryASTFactory;
    }

    public createCreateOperation({
        entity,
        resolveTree,
        callbackBucket,
        context,
    }: {
        entity: ConcreteEntityAdapter;
        resolveTree: ResolveTree;
        callbackBucket: CallbackBucket;
        context: Neo4jGraphQLTranslationContext;
    }): TopLevelCreateMutationOperation {
        const responseFields = Object.values(
            resolveTree.fieldsByTypeName[entity.operations.mutationResponseTypeNames.create] ?? {}
        );

        const rawInput = resolveTree.args.input as Record<string, any>[];
        const input = rawInput ?? [];
        const createOperations: CreateOperation[] = input.map((inputItem) => {
            const createOperation = new CreateOperation({
                target: entity,
                selectionPattern: new NodeSelectionPattern({
                    target: entity,
                }),
            });

            this.hydrateCreateOperation({
                target: entity,
                input: inputItem,
                create: createOperation,
                callbackBucket,
                context,
            });

            return createOperation;
        });

        const projectionOperations = responseFields
            .filter((f) => f.name === entity.plural)
            .map((field) => {
                const readOP = this.queryASTFactory.operationsFactory.createReadOperation({
                    entityOrRel: entity,
                    resolveTree: field,
                    context,
                }) as ReadOperation;

                const fieldOperation = new OperationField({
                    operation: readOP,
                    alias: field.alias,
                });
                return fieldOperation;
            });

        const topLevelMutation = new TopLevelCreateMutationOperation({
            createOperations,
            projectionOperations,
        });
        return topLevelMutation;
    }

    public createUnwindCreateOperation(
        entity: ConcreteEntityAdapter,
        resolveTree: ResolveTree,
        context: Neo4jGraphQLTranslationContext
    ): UnwindCreateOperation {
        const responseFields = Object.values(
            resolveTree.fieldsByTypeName[entity.operations.mutationResponseTypeNames.create] ?? {}
        );
        const rawInput = resolveTree.args.input as Record<string, any>[];
        const input = rawInput ?? [];
        const unwindCreate = this.parseUnwindCreate({
            target: entity,
            input,
            context,
            argumentToUnwind: new Cypher.Param(input),
        });

        const projectionFields = responseFields
            .filter((f) => f.name === entity.plural)
            .map((field) => {
                return this.queryASTFactory.operationsFactory.createReadOperation({
                    entityOrRel: entity,
                    resolveTree: field,
                    context,
                }) as ReadOperation;
            });

        unwindCreate.addProjectionOperations(projectionFields);
        return unwindCreate;
    }

    private parseUnwindCreate({
        target,
        relationship,
        input,
        context,
        argumentToUnwind,
    }: {
        target: ConcreteEntityAdapter;
        relationship?: RelationshipAdapter;
        input: Record<string, any>[];
        context: Neo4jGraphQLTranslationContext;
        argumentToUnwind: Cypher.Property | Cypher.Param;
    }): UnwindCreateOperation {
        const isNested = Boolean(relationship);

        const unwindCreate = new UnwindCreateOperation({
            target: relationship ?? target,
            argumentToUnwind,
        });
        this.addEntityAuthorization({ entity: target, context, operation: unwindCreate });
        this.addAuthorizationsForAttributesInUnwind({
            target,
            context,
            unwindCreate: unwindCreate,
            isNested,
        });
        this.hydrateUnwindCreateOperation({
            target,
            relationship,
            input,
            unwindCreate,
            context,
        });

        return unwindCreate;
    }

    private hydrateUnwindCreateOperation({
        target,
        relationship,
        input,
        unwindCreate,
        context,
    }: {
        target: ConcreteEntityAdapter;
        relationship?: RelationshipAdapter;
        input: Record<string, any>[];
        unwindCreate: UnwindCreateOperation;
        context: Neo4jGraphQLTranslationContext;
    }) {
        const isNested = Boolean(relationship);
        // TODO: there is no need to get always the autogenerated field as these are static fields and can be cached
        [target, relationship].forEach((t) =>
            this.addAutogeneratedFieldsToUnwindCreate({
                target: t,
                unwindCreate,
            })
        );
        asArray(input).forEach((inputItem) => {
            const targetInput = this.getInputNode(inputItem, isNested);
            raiseAttributeAmbiguity(Object.keys(targetInput), target);
            raiseAttributeAmbiguity(Object.keys(this.getInputEdge(target)), relationship);
            for (const key of Object.keys(targetInput)) {
                const nestedRelationship = target.relationships.get(key);
                const attribute = target.attributes.get(key);
                if (!attribute && !nestedRelationship) {
                    throw new Error(`Transpile Error: Input field ${key} not found in entity ${target.name}`);
                }
                if (attribute) {
                    this.parseAttributeInputField({
                        target,
                        attribute,
                        unwindCreate,
                    });
                } else if (nestedRelationship) {
                    const nestedEntity = nestedRelationship.target;
                    assertIsConcreteEntity(nestedEntity);
                    const relField = unwindCreate.getField(key, "node");
                    const nestedCreateInput = targetInput[key]?.create;
                    if (
                        relField &&
                        relField instanceof MutationOperationField &&
                        relField.mutationOperation instanceof UnwindCreateOperation
                    ) {
                        // in case relationship field is already present in the unwind operation we want still to hydrate the unwind-create operation as it might have different fields.
                        this.hydrateUnwindCreateOperation({
                            target: nestedEntity,
                            relationship: nestedRelationship,
                            input: nestedCreateInput,
                            unwindCreate: relField.mutationOperation,
                            context,
                        });
                    }
                    this.addRelationshipInputFieldToUnwindOperation({
                        relationship: nestedRelationship,
                        unwindCreate,
                        context,
                        nestedCreateInput,
                        isNested,
                    });
                }
            }
            if (relationship) {
                for (const key of Object.keys(this.getInputEdge(inputItem))) {
                    const attribute = relationship.attributes.get(key);
                    if (attribute) {
                        this.parseAttributeInputField({
                            target: relationship,
                            attribute,
                            unwindCreate,
                        });
                    }
                }
            }
        });
    }

    private hydrateCreateOperation({
        target,
        relationship,
        input,
        create,
        callbackBucket,
        context,
    }: {
        target: ConcreteEntityAdapter;
        relationship?: RelationshipAdapter;
        input: Record<string, any>;
        create: CreateOperation;
        callbackBucket: CallbackBucket;
        context: Neo4jGraphQLTranslationContext;
    }) {
        const isNested = Boolean(relationship);
        // TODO: there is no need to get always the autogenerated field as these are static fields and can be cached
        [target, relationship].forEach((t) => {
            if (!t) {
                return;
            }
            const autoGeneratedFields = getAutogeneratedFields(t);

            autoGeneratedFields.forEach((field) => {
                create.addField(field);
            });
        });

        this.addEntityAuthorization({ entity: target, context, operation: create });

        asArray(input).forEach((inputItem) => {
            const targetInput = this.getInputNode(inputItem, isNested);
            raiseAttributeAmbiguity(Object.keys(targetInput), target);
            raiseAttributeAmbiguity(Object.keys(this.getInputEdge(inputItem)), relationship);
            for (const key of Object.keys(targetInput)) {
                const nestedRelationship = target.relationships.get(key);
                const attribute = target.attributes.get(key);
                if (!attribute && !nestedRelationship) {
                    throw new Error(`Transpile Error: Input field ${key} not found in entity ${target.name}`);
                }
                if (attribute) {
                    const paramInputField = new ParamInputField({
                        attachedTo: "node",
                        attribute,
                        inputValue: targetInput[key],
                    });
                    create.addField(paramInputField);

                    this.addAttributeAuthorization({
                        attribute,
                        context,
                        unwindCreate: create,
                        entity: target,
                    });
                } else if (nestedRelationship) {
                    const nestedEntity = nestedRelationship.target;
                    const operationInput = targetInput[key] ?? {};

                    const entityAndNodeInput: Array<
                        [ConcreteEntityAdapter | InterfaceEntityAdapter, Record<string, any>]
                    > = [];

                    if (isUnionEntity(nestedEntity)) {
                        Object.entries(operationInput).forEach(([entityTypename, input]) => {
                            const concreteNestedEntity = nestedEntity.concreteEntities.find(
                                (e) => e.name === entityTypename
                            );
                            if (!concreteNestedEntity) {
                                throw new Error("Concrete entity not found in create, please contact support");
                            }

                            entityAndNodeInput.push([concreteNestedEntity, input as any]);
                        });
                    } else {
                        entityAndNodeInput.push([nestedEntity, operationInput]);
                    }

                    entityAndNodeInput.forEach(([nestedEntity, operationInput]) => {
                        const nestedCreateInput = operationInput.create;
                        if (nestedCreateInput) {
                            this.createNestedCreateOperation({
                                targetEntity: nestedEntity,
                                relationship: nestedRelationship,
                                input: nestedCreateInput,
                                callbackBucket,
                                context,
                                operation: create,
                                key,
                            });
                        }
                        const nestedConnectInput = operationInput.connect;
                        if (nestedConnectInput) {
                            asArray(nestedConnectInput).forEach((nestedConnectInputItem) => {
                                const nestedConnectOperation =
                                    this.queryASTFactory.operationsFactory.createConnectOperation(
                                        nestedEntity,
                                        nestedRelationship,
                                        nestedConnectInputItem,
                                        context,
                                        callbackBucket
                                    );

                                const mutationOperationField = new MutationOperationField(nestedConnectOperation, key);
                                create.addField(mutationOperationField);
                            });
                        }
                    });
                }
            }
            if (relationship) {
                const targetInputEdge = this.getInputEdge(inputItem);
                for (const key of Object.keys(targetInputEdge)) {
                    const attribute = relationship.attributes.get(key);
                    if (attribute) {
                        const attachedTo = "relationship";

                        const paramInputField = new ParamInputField({
                            attachedTo,
                            attribute,
                            inputValue: targetInputEdge[key],
                        });
                        create.addField(paramInputField);
                    }
                }
            }
        });

        this.addPopulatedByFieldToCreate({
            entity: target,
            create,
            input,
            callbackBucket,
            relationship,
        });
    }

    public createNestedCreateOperation({
        relationship,
        targetEntity,
        input,
        callbackBucket,
        context,
        operation,
        key,
    }: {
        input: Record<string, any> | Array<Record<string, any>>;
        targetEntity: ConcreteEntityAdapter | InterfaceEntityAdapter;
        relationship: RelationshipAdapter;
        callbackBucket: CallbackBucket;
        context: Neo4jGraphQLTranslationContext;
        operation: CreateOperation | UpdateOperation;
        key: string;
    }) {
        asArray(input).forEach((input) => {
            const edgeFields = input.edge ?? {};
            const nodeInputFields = input.node ?? {};

            const entityAndNodeInput: Array<[ConcreteEntityAdapter, Record<string, any>]> = [];

            if (isConcreteEntity(targetEntity)) {
                entityAndNodeInput.push([targetEntity, nodeInputFields]);
            } else {
                Object.entries(nodeInputFields).forEach(([concreteTypename, nodeInputFields]) => {
                    const concreteEntity = targetEntity.concreteEntities.find((e) => e.name === concreteTypename);
                    if (!concreteEntity) {
                        throw new Error("Concrete entity not found in create, please contact support");
                    }
                    entityAndNodeInput.push([concreteEntity, nodeInputFields as Record<string, any>]);
                });
            }

            entityAndNodeInput.forEach(([concreteEntity, nodeInputFields]) => {
                const nestedCreateOperation = new CreateOperation({
                    target: concreteEntity,
                    relationship,
                    selectionPattern: new RelationshipSelectionPattern({
                        relationship,
                    }),
                });

                this.hydrateCreateOperation({
                    create: nestedCreateOperation,
                    target: concreteEntity,
                    relationship,
                    input: {
                        node: nodeInputFields,
                        edge: edgeFields,
                    },
                    callbackBucket,
                    context,
                });

                const mutationOperationField = new MutationOperationField(nestedCreateOperation, key);
                operation.addField(mutationOperationField);
            });
        });
    }

    private addPopulatedByFieldToCreate({
        entity,
        create,
        input,
        callbackBucket,
        relationship,
    }: {
        entity: ConcreteEntityAdapter;
        create: CreateOperation;
        input: Record<string, any>;
        callbackBucket: CallbackBucket;
        relationship?: RelationshipAdapter;
    }) {
        entity.getPopulatedByFields("CREATE").forEach((attribute) => {
            const attachedTo = "node";
            // the param value it's irrelevant as it will be overwritten by the callback function
            const callbackParam = new Cypher.Param("");
            const field = new ParamInputField({
                attribute,
                attachedTo,
                inputValue: callbackParam,
            });
            create.addField(field);

            const callbackFunctionName = attribute.annotations.populatedBy?.callback;
            if (!callbackFunctionName) {
                throw new Error(`PopulatedBy callback not found for attribute ${attribute.name}`);
            }

            const callbackParent = relationship ? input.node : input;

            callbackBucket.addCallback({
                functionName: callbackFunctionName,
                param: callbackParam,
                parent: callbackParent,
                type: attribute.type,
                operation: "CREATE",
            });
        });

        if (relationship) {
            relationship.getPopulatedByFields("CREATE").forEach((attribute) => {
                const attachedTo = "relationship";
                // the param value it's irrelevant as it will be overwritten by the callback function
                const relCallbackParam = new Cypher.Param("");
                const relField = new ParamInputField({
                    attribute,
                    attachedTo,
                    inputValue: relCallbackParam,
                });
                create.addField(relField);

                const callbackFunctionName = attribute.annotations.populatedBy?.callback;
                if (!callbackFunctionName) {
                    throw new Error(`PopulatedBy callback not found for attribute ${attribute.name}`);
                }

                callbackBucket.addCallback({
                    functionName: callbackFunctionName,
                    param: relCallbackParam,
                    parent: input.edge,
                    type: attribute.type,
                    operation: "CREATE",
                });
            });
        }
    }

    private getInputNode(inputItem: Record<string, any>, isNested: boolean): Record<string, any> {
        if (isNested) {
            return inputItem.node ?? {};
        }
        return inputItem;
    }

    private getInputEdge(inputItem: Record<string, any>): Record<string, any> {
        return inputItem.edge ?? {};
    }

    private addAutogeneratedFieldsToUnwindCreate({
        target,
        unwindCreate,
    }: {
        target: ConcreteEntityAdapter | RelationshipAdapter | undefined;
        unwindCreate: UnwindCreateOperation;
    }): void {
        if (!target) {
            return;
        }
        const attachedTo = isConcreteEntity(target) ? "node" : "relationship";
        const autoGeneratedFields = getAutogeneratedFields(target);

        autoGeneratedFields.forEach((field) => {
            if (unwindCreate.getField(field.name, attachedTo)) {
                return;
            }
            unwindCreate.addField(field, attachedTo);
        });
    }

    private parseAttributeInputField({
        target,
        attribute,
        unwindCreate,
    }: {
        target: ConcreteEntityAdapter | RelationshipAdapter;
        attribute: AttributeAdapter;
        unwindCreate: UnwindCreateOperation;
    }) {
        const isConcreteEntityTarget = isConcreteEntity(target);
        const attachedTo = isConcreteEntityTarget ? "node" : "relationship";

        this.addAttributeInputFieldToUnwindOperation({
            attribute,
            unwindCreate,
            attachedTo,
        });
    }

    private getEdgeOrNodePath({
        unwindVariable,
        isNested,
        isRelField,
    }: {
        unwindVariable: Cypher.Variable | Cypher.Property | Cypher.Param;
        isNested: boolean;
        isRelField: boolean;
    }): Cypher.Property | Cypher.Variable {
        if (!isNested && isRelField) {
            throw new Error("Transpile error: invalid invoke of getEdgeOrNodePath for relationship field.");
        }

        if (isNested) {
            const path = isRelField ? "edge" : "node";
            return unwindVariable.property(path);
        }
        return unwindVariable;
    }

    private addAttributeInputFieldToUnwindOperation({
        attribute,
        unwindCreate,
        attachedTo,
    }: {
        attribute: AttributeAdapter;
        unwindCreate: UnwindCreateOperation;
        attachedTo: "relationship" | "node";
    }): void {
        if (unwindCreate.getField(attribute.name, attachedTo)) {
            return;
        }

        const inputField = new PropertyInputField({
            attribute,
            attachedTo,
        });

        unwindCreate.addField(inputField, attachedTo);
    }

    private addRelationshipInputFieldToUnwindOperation({
        relationship,
        unwindCreate,
        context,
        nestedCreateInput,
        isNested,
    }: {
        relationship: RelationshipAdapter;
        unwindCreate: UnwindCreateOperation;
        context: Neo4jGraphQLTranslationContext;
        nestedCreateInput: Record<string, any>[];
        isNested: boolean;
    }): void {
        const relField = unwindCreate.getField(relationship.name, "node");
        if (!relField) {
            if (nestedCreateInput) {
                const partialPath = this.getEdgeOrNodePath({
                    unwindVariable: unwindCreate.getCypherVariable(),
                    isNested,
                    isRelField: false,
                });
                const path = partialPath.property(relationship.name).property("create");
                const nestedUnwind = this.parseUnwindCreate({
                    target: relationship.target as ConcreteEntityAdapter,
                    relationship: relationship,
                    input: nestedCreateInput,
                    argumentToUnwind: path,
                    context,
                });

                const mutationOperationField = new MutationOperationField(nestedUnwind, relationship.name);
                unwindCreate.addField(mutationOperationField, "node");
            } else {
                throw new Error(`Expected create operation, but found: ${relationship.name}`);
            }
        }
    }

    private addEntityAuthorization({
        entity,
        context,
        operation,
    }: {
        entity: ConcreteEntityAdapter;
        context: Neo4jGraphQLTranslationContext;
        operation: UnwindCreateOperation | CreateOperation;
    }): void {
        const authFilters = this.queryASTFactory.authorizationFactory.createAuthValidateRule({
            entity,
            authAnnotation: entity.annotations.authorization,
            when: "AFTER",
            operations: ["CREATE"],
            context,
        });
        if (authFilters) {
            operation.addAuthFilters(authFilters);
        }
    }

    private addAttributeAuthorization({
        attribute,
        context,
        unwindCreate,
        entity,
        conditionForEvaluation,
    }: {
        attribute: AttributeAdapter;
        context: Neo4jGraphQLTranslationContext;
        unwindCreate: UnwindCreateOperation | CreateOperation;
        entity: ConcreteEntityAdapter;
        conditionForEvaluation?: Cypher.Predicate;
    }): void {
        const attributeAuthorization = this.queryASTFactory.authorizationFactory.createAuthValidateRule({
            entity,
            when: "AFTER",
            authAnnotation: attribute.annotations.authorization,
            conditionForEvaluation,
            operations: ["CREATE"],
            context,
        });
        if (attributeAuthorization) {
            unwindCreate.addAuthFilters(attributeAuthorization);
        }
    }

    private addAuthorizationsForAttributesInUnwind({
        target,
        context,
        unwindCreate,
        isNested,
    }: {
        target: ConcreteEntityAdapter;
        context: Neo4jGraphQLTranslationContext;
        unwindCreate: UnwindCreateOperation;
        isNested: boolean;
    }): void {
        const edgeOrNodePath = this.getEdgeOrNodePath({
            unwindVariable: unwindCreate.getCypherVariable(),
            isRelField: false,
            isNested,
        });

        for (const attribute of target.attributes.values()) {
            const path = edgeOrNodePath.property(attribute.name);
            this.addAttributeAuthorization({
                attribute,
                context,
                unwindCreate,
                entity: target,
                conditionForEvaluation: Cypher.isNotNull(path),
            });
        }
    }
}
