/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Cypher from "@neo4j/cypher-builder";
import { GraphQLError } from "graphql";
import type { ResolveTree } from "graphql-parse-resolve-info";
import type { AttributeAdapter } from "../../../../schema-model/attribute/model-adapters/AttributeAdapter";
import type { ConcreteEntityAdapter } from "../../../../schema-model/entity/model-adapters/ConcreteEntityAdapter";
import type { InterfaceEntityAdapter } from "../../../../schema-model/entity/model-adapters/InterfaceEntityAdapter";
import type { RelationshipAdapter } from "../../../../schema-model/relationship/model-adapters/RelationshipAdapter";
import type { Neo4jGraphQLTranslationContext } from "../../../../types/neo4j-graphql-translation-context";
import { asArray } from "../../../../utils/utils";
import { OperationField } from "../../ast/fields/OperationField";
import { type InputField } from "../../ast/input-fields/InputField";
import { MutationOperationField } from "../../ast/input-fields/MutationOperationField";
import { MathInputField } from "../../ast/input-fields/operators/MathInputField";
import { PopInputField } from "../../ast/input-fields/operators/PopInputField";
import { PushInputField } from "../../ast/input-fields/operators/PushInputField";
import { ParamInputField } from "../../ast/input-fields/ParamInputField";
import type { ReadOperation } from "../../ast/operations/ReadOperation";
import { TopLevelUpdateMutationOperation } from "../../ast/operations/TopLevelUpdateMutationOperation";
import { UpdateOperation } from "../../ast/operations/UpdateOperation";
import { NodeSelectionPattern } from "../../ast/selection/SelectionPattern/NodeSelectionPattern";
import { RelationshipSelectionPattern } from "../../ast/selection/SelectionPattern/RelationshipSelectionPattern";
import type { CallbackBucket } from "../../utils/callback-bucket";
import { isConcreteEntity } from "../../utils/is-concrete-entity";
import { isUnionEntity } from "../../utils/is-union-entity";
import { raiseAttributeAmbiguityForUpdate } from "../../utils/raise-attribute-ambiguity";
import { getAutogeneratedFieldsForUpdate } from "../parsers/get-autogenerated-fields";
import type { MutationOperator } from "../parsers/parse-mutation-field";
import { parseMutationField } from "../parsers/parse-mutation-field";
import type { QueryASTFactory } from "../QueryASTFactory";

export class UpdateFactory {
    private queryASTFactory: QueryASTFactory;

    constructor(queryASTFactory: QueryASTFactory) {
        this.queryASTFactory = queryASTFactory;
    }

    public createUpdateOperation(
        entity: ConcreteEntityAdapter,
        resolveTree: ResolveTree,
        context: Neo4jGraphQLTranslationContext,
        callbackBucket: CallbackBucket,
        varName: string | undefined
    ): TopLevelUpdateMutationOperation {
        const rawInput = resolveTree.args.update as Record<string, any>[];
        const input = asArray(rawInput) ?? [];

        if (!input.length) {
            // dummy input to translate top level match for the projection to work
            input.push({});
        }

        const updateOperations = input.map((inputItem) => {
            const updateOperation = new UpdateOperation({
                target: entity,
                selectionPattern: new NodeSelectionPattern({
                    target: entity,
                    alias: varName,
                }),
            });

            this.hydrateUpdateOperation({
                target: entity,
                input: inputItem,
                update: updateOperation,
                callbackBucket,
                context,
                whereArgs: {
                    node: (resolveTree.args.where as Record<string, any>) ?? {},
                },
            });

            return updateOperation;
        });

        const responseFields = Object.values(
            resolveTree.fieldsByTypeName[entity.operations.mutationResponseTypeNames.update] ?? {}
        );

        const projectionOperations = responseFields
            .filter((f) => f.name === entity.plural)
            .map((field) => {
                const readOP = this.queryASTFactory.operationsFactory.createReadOperation({
                    entityOrRel: entity,
                    resolveTree: field,
                    context,
                }) as ReadOperation;

                const fieldOperation = new OperationField({
                    operation: readOP,
                    alias: field.alias,
                });
                return fieldOperation;
            });
        const topLevelMutation = new TopLevelUpdateMutationOperation({
            updateOperations,
            projectionOperations,
        });
        return topLevelMutation;
    }

    private hydrateUpdateOperation({
        target,
        relationship,
        input,
        update,
        callbackBucket,
        context,
        whereArgs,
    }: {
        target: ConcreteEntityAdapter;
        relationship?: RelationshipAdapter;
        input: Record<string, any>;
        update: UpdateOperation;
        callbackBucket: CallbackBucket;
        context: Neo4jGraphQLTranslationContext;
        whereArgs: {
            node: Record<string, any>;
            edge?: Record<string, any>;
        };
    }) {
        const isNested = Boolean(relationship);

        const autoGeneratedFields = getAutogeneratedFieldsForUpdate(target);
        autoGeneratedFields.forEach((field) => {
            update.addField(field);
        });

        if (relationship) {
            const autoGeneratedFields = getAutogeneratedFieldsForUpdate(relationship);
            autoGeneratedFields.forEach((field) => {
                field.attachedTo = "relationship";
                update.addField(field);
            });
        }

        if (this.shouldApplyUpdateAuthorization(input, target, isNested)) {
            this.addEntityAuthorization({ entity: target, context, operation: update });
        }
        asArray(input).forEach((inputItem) => {
            const targetInput = this.getInputNode(inputItem, isNested);
            raiseAttributeAmbiguityForUpdate(Object.keys(targetInput), target);
            raiseAttributeAmbiguityForUpdate(Object.keys(this.getInputEdge(inputItem)), relationship);

            if (whereArgs) {
                const filters = this.queryASTFactory.filterFactory.createConnectionPredicates({
                    rel: relationship,
                    entity: target,
                    where: whereArgs,
                });
                update.addFilters(...filters);
            }
            for (const key of Object.keys(targetInput)) {
                const { fieldName, operator } = parseMutationField(key);
                const nestedRelationship = target.relationships.get(fieldName);
                const attribute = target.attributes.get(fieldName);
                if (!attribute && !nestedRelationship) {
                    throw new Error(`Transpile Error: Input field ${key} not found in entity ${target.name}`);
                }
                if (attribute) {
                    if (operator) {
                        const value = targetInput[key];
                        if (attribute.typeHelper.isRequired() && value === null && operator === "SET") {
                            throw new Error(`Cannot set non-nullable field ${target.name}.${attribute.name} to null`);
                        }
                        const paramInputField = this.getInputFieldDeprecated("node", operator, attribute, value);
                        update.addField(paramInputField);

                        this.addAttributeAuthorization({
                            attribute,
                            context,
                            update,
                            entity: target,
                        });
                    } else {
                        const operations = Object.keys(targetInput[fieldName]);
                        if (operations.length > 1) {
                            const conflictingOperations = operations.map((op) => `[[${op}]]`);
                            throw new GraphQLError(
                                `Conflicting modification of field ${fieldName}: ${conflictingOperations.join(", ")} on type ${target.name}`
                            );
                        }
                        for (const op of Object.keys(targetInput[fieldName])) {
                            const value = targetInput[fieldName][op];
                            if (attribute.typeHelper.isRequired() && value === null && op === "set") {
                                throw new Error(
                                    `Cannot set non-nullable field ${target.name}.${attribute.name} to null`
                                );
                            }
                            const paramInputField = this.getInputField("node", op, attribute, value);
                            update.addField(paramInputField);

                            this.addAttributeAuthorization({
                                attribute,
                                context,
                                update,
                                entity: target,
                            });
                        }
                    }
                } else if (nestedRelationship) {
                    const nestedEntity = nestedRelationship.target;
                    const operationInput = targetInput[key] ?? {};

                    const entityAndNodeInput: Array<
                        [ConcreteEntityAdapter | InterfaceEntityAdapter, Record<string, any>]
                    > = [];

                    if (isUnionEntity(nestedEntity)) {
                        Object.entries(operationInput).forEach(([entityTypename, input]) => {
                            const concreteNestedEntity = nestedEntity.concreteEntities.find(
                                (e) => e.name === entityTypename
                            );
                            if (!concreteNestedEntity) {
                                throw new Error("Concrete entity not found in create, please contact support");
                            }

                            entityAndNodeInput.push([concreteNestedEntity, input as any]);
                        });
                    } else {
                        entityAndNodeInput.push([nestedEntity, operationInput]);
                    }

                    entityAndNodeInput.forEach(([nestedEntity, operations]) => {
                        operations.forEach((operationInput: Record<string, any>) => {
                            const nestedUpdateInput = operationInput.update;
                            if (nestedUpdateInput) {
                                asArray(nestedUpdateInput).forEach((nestedUpdateInputItem) => {
                                    this.createNestedUpdateOperation({
                                        nestedEntity,
                                        nestedRelationship,
                                        nestedUpdateInputItem,
                                        context,
                                        callbackBucket,
                                        operation: update,
                                        key,
                                    });
                                });
                            }
                            const nestedCreateInput = operationInput.create;
                            if (nestedCreateInput) {
                                asArray(nestedCreateInput).forEach((nestedCreateInputItem) => {
                                    let edgeField = nestedCreateInputItem.edge ?? {};

                                    // This is to parse the create input for a declareRelationship
                                    // We are checking the relationship target, because for nestedRelationship is
                                    // already disambiguated into concrete entity
                                    if (relationship?.target && !isConcreteEntity(relationship?.target)) {
                                        if (nestedRelationship.propertiesTypeName) {
                                            edgeField = edgeField[nestedRelationship.propertiesTypeName] ?? {};
                                        }
                                    }

                                    const concreteNestedCreateInput = {
                                        node: nestedCreateInputItem.node ?? {},
                                        edge: edgeField,
                                    };

                                    this.queryASTFactory.operationsFactory.createNestedCreateOperation({
                                        targetEntity: nestedEntity,
                                        relationship: nestedRelationship,
                                        input: concreteNestedCreateInput,
                                        context,
                                        callbackBucket,
                                        key,
                                        operation: update,
                                    });
                                });
                            }
                            const nestedConnectInput = operationInput.connect;
                            if (nestedConnectInput) {
                                asArray(nestedConnectInput).forEach((nestedConnectInputItem) => {
                                    const nestedConnectOperation =
                                        this.queryASTFactory.operationsFactory.createConnectOperation(
                                            nestedEntity,
                                            nestedRelationship,
                                            nestedConnectInputItem,
                                            context,
                                            callbackBucket
                                        );

                                    const mutationOperationField = new MutationOperationField(
                                        nestedConnectOperation,
                                        key
                                    );
                                    update.addField(mutationOperationField);
                                });
                            }
                            const nestedDeleteInput = operationInput.delete;
                            if (nestedDeleteInput) {
                                asArray(nestedDeleteInput).forEach((nestedDeleteInputItem) => {
                                    const nestedDeleteOperations =
                                        this.queryASTFactory.operationsFactory.createNestedDeleteOperationsForUpdate(
                                            nestedDeleteInputItem,
                                            nestedRelationship,
                                            context,
                                            nestedEntity
                                        );
                                    for (const nestedDeleteOperation of nestedDeleteOperations) {
                                        const mutationOperationField = new MutationOperationField(
                                            nestedDeleteOperation,
                                            key
                                        );
                                        update.addField(mutationOperationField);
                                    }
                                });
                            }
                            const nestedDisconnectInput = operationInput.disconnect;
                            if (nestedDisconnectInput) {
                                asArray(nestedDisconnectInput).forEach((nestedDisconnectInputItem) => {
                                    const nestedDisconnectOperation =
                                        this.queryASTFactory.operationsFactory.createDisconnectOperation(
                                            nestedEntity,
                                            nestedRelationship,
                                            nestedDisconnectInputItem,
                                            context,
                                            callbackBucket
                                        );

                                    const mutationOperationField = new MutationOperationField(
                                        nestedDisconnectOperation,
                                        key
                                    );
                                    update.addField(mutationOperationField);
                                });
                            }
                        });
                    });
                }
            }

            if (relationship) {
                const targetInputEdge = this.getInputEdge(inputItem);
                for (const key of Object.keys(targetInputEdge)) {
                    const { fieldName, operator } = parseMutationField(key);
                    const attribute = relationship.attributes.get(fieldName);
                    if (attribute) {
                        if (operator) {
                            const paramInputField = this.getInputFieldDeprecated(
                                "relationship",
                                operator,
                                attribute,
                                targetInputEdge[key]
                            );
                            update.addField(paramInputField);

                            this.addAttributeAuthorization({
                                attribute,
                                context,
                                update,
                                entity: target,
                            });
                        } else {
                            const operations = Object.keys(targetInputEdge[fieldName]);
                            if (operations.length > 1) {
                                const conflictingOperations = operations.map((op) => `[[${op}]]`);
                                throw new GraphQLError(
                                    `Conflicting modification of field ${fieldName}: ${conflictingOperations.join(", ")} on relationship ${target.name}.${relationship.name}`
                                );
                            }
                            for (const op of operations) {
                                const paramInputField = this.getInputField(
                                    "relationship",
                                    op,
                                    attribute,
                                    targetInputEdge[fieldName][op]
                                );
                                update.addField(paramInputField);

                                this.addAttributeAuthorization({
                                    attribute,
                                    context,
                                    update,
                                    entity: target,
                                });
                            }
                        }
                    } else if (key === relationship.propertiesTypeName) {
                        const edgeInput = targetInputEdge[key]; // ActedIn: {..}
                        for (const k of Object.keys(edgeInput)) {
                            const { fieldName, operator } = parseMutationField(k);
                            const attribute = relationship.attributes.get(fieldName);
                            if (attribute) {
                                if (operator) {
                                    const paramInputField = this.getInputFieldDeprecated(
                                        "relationship",
                                        operator,
                                        attribute,
                                        edgeInput[k]
                                    );
                                    update.addField(paramInputField);

                                    this.addAttributeAuthorization({
                                        attribute,
                                        context,
                                        update,
                                        entity: target,
                                    });
                                } else {
                                    for (const op of Object.keys(edgeInput[k][fieldName])) {
                                        const paramInputField = this.getInputField(
                                            "relationship",
                                            op,
                                            attribute,
                                            edgeInput[fieldName][op]
                                        );
                                        update.addField(paramInputField);

                                        this.addAttributeAuthorization({
                                            attribute,
                                            context,
                                            update,
                                            entity: target,
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
                if (Object.keys(targetInputEdge).length > 0) {
                    this.addPopulatedByFieldToUpdate({
                        entity: target,
                        update,
                        input: targetInputEdge,
                        callbackBucket,
                        relationship,
                    });
                }
            }
            this.addPopulatedByFieldToUpdate({
                entity: target,
                update,
                input: targetInput,
                callbackBucket,
            });
        });
    }

    private addPopulatedByFieldToUpdate({
        entity,
        update,
        input,
        callbackBucket,
        relationship,
    }: {
        entity: ConcreteEntityAdapter;
        update: UpdateOperation;
        input: Record<string, any>;
        callbackBucket: CallbackBucket;
        relationship?: RelationshipAdapter;
    }) {
        entity.getPopulatedByFields("UPDATE").forEach((attribute) => {
            const attachedTo = "node";
            // the param value it's irrelevant as it will be overwritten by the callback function
            const callbackParam = new Cypher.Param("");
            const field = new ParamInputField({
                attribute,
                attachedTo,
                inputValue: callbackParam,
            });
            update.addField(field);

            const callbackFunctionName = attribute.annotations.populatedBy?.callback;
            if (!callbackFunctionName) {
                throw new Error(`PopulatedBy callback not found for attribute ${attribute.name}`);
            }

            const callbackParent = relationship ? input.node : input;

            callbackBucket.addCallback({
                functionName: callbackFunctionName,
                param: callbackParam,
                parent: callbackParent,
                type: attribute.type,
                operation: "UPDATE",
            });
        });

        if (relationship) {
            relationship.getPopulatedByFields("UPDATE").forEach((attribute) => {
                const attachedTo = "relationship";
                // the param value it's irrelevant as it will be overwritten by the callback function
                const relCallbackParam = new Cypher.Param("");
                const relField = new ParamInputField({
                    attribute,
                    attachedTo,
                    inputValue: relCallbackParam,
                });
                update.addField(relField);

                const callbackFunctionName = attribute.annotations.populatedBy?.callback;
                if (!callbackFunctionName) {
                    throw new Error(`PopulatedBy callback not found for attribute ${attribute.name}`);
                }

                callbackBucket.addCallback({
                    functionName: callbackFunctionName,
                    param: relCallbackParam,
                    parent: input,
                    type: attribute.type,
                    operation: "UPDATE",
                });
            });
        }
    }

    private addEntityAuthorization({
        entity,
        context,
        operation,
    }: {
        entity: ConcreteEntityAdapter;
        context: Neo4jGraphQLTranslationContext;
        operation: UpdateOperation;
    }): void {
        const authFilters = this.queryASTFactory.authorizationFactory.getAuthFilters({
            entity,
            operations: ["UPDATE"],
            context,
            afterValidation: true,
        });

        operation.addAuthFilters(...authFilters);
    }

    private addAttributeAuthorization({
        attribute,
        context,
        update,
        entity,
        conditionForEvaluation,
    }: {
        attribute: AttributeAdapter;
        context: Neo4jGraphQLTranslationContext;
        update: UpdateOperation;
        entity: ConcreteEntityAdapter;
        conditionForEvaluation?: Cypher.Predicate;
    }): void {
        const authBeforeFilters = this.queryASTFactory.authorizationFactory.createAuthValidateRule({
            entity,
            authAnnotation: attribute.annotations.authorization,
            when: "BEFORE",
            conditionForEvaluation,
            operations: ["UPDATE"],
            context,
        });
        if (authBeforeFilters) {
            update.addAuthFilters(authBeforeFilters);
        }
        const attributeAuthorization = this.queryASTFactory.authorizationFactory.createAuthValidateRule({
            entity,
            when: "AFTER",
            authAnnotation: attribute.annotations.authorization,
            conditionForEvaluation,
            operations: ["UPDATE"],
            context,
        });
        if (attributeAuthorization) {
            update.addAuthFilters(attributeAuthorization);
        }
    }

    // returns true only if actual attributes are modified
    // UPDATE rules should not be applied for (dis)connections
    private shouldApplyUpdateAuthorization(
        input: Record<string, any>,
        entity: ConcreteEntityAdapter,
        isNested: boolean
    ): boolean {
        const actualInput = this.getInputNode(input, isNested);
        const affectedKeys = Object.keys(actualInput).map((key) => {
            // old version compatibility (eg id_SET)
            const { fieldName } = parseMutationField(key);
            return fieldName;
        });
        const areAttributesAffected = affectedKeys.filter((k) => entity.attributes.has(k)).length > 0;

        const isRelationshipUpdated =
            isNested &&
            affectedKeys
                .filter((k) => entity.relationships.has(k))
                .some((k) => {
                    return asArray(actualInput[k]).filter((inputItem) => inputItem.update);
                });

        return areAttributesAffected || isRelationshipUpdated;
    }

    private getInputNode(inputItem: Record<string, any>, isNested: boolean): Record<string, any> {
        if (isNested) {
            return inputItem.node ?? {};
        }
        return inputItem;
    }

    private getInputEdge(inputItem: Record<string, any>): Record<string, any> {
        return inputItem.edge ?? {};
    }

    private getInputFieldDeprecated(
        attachedTo: "node" | "relationship",
        operator: MutationOperator | undefined,
        attribute: AttributeAdapter,
        value: unknown
    ): InputField {
        switch (operator) {
            case "SET":
                return new ParamInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                });
            case "INCREMENT":
            case "DECREMENT":
            case "ADD":
            case "SUBTRACT":
            case "DIVIDE":
            case "MULTIPLY":
                return new MathInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                    operation: operator.toLowerCase() as any,
                });
            case "PUSH":
                return new PushInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                });
            case "POP":
                return new PopInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                });
            default:
                throw new Error(`Unsupported update operator ${operator} on field ${attribute.name} `);
        }
    }
    private getInputField(
        attachedTo: "node" | "relationship",
        operator: string | undefined,
        attribute: AttributeAdapter,
        value: unknown
    ): InputField {
        switch (operator) {
            case "set":
                return new ParamInputField({
                    attachedTo: "node",
                    attribute,
                    inputValue: value,
                });
            case "increment":
            case "decrement":
            case "add":
            case "subtract":
            case "divide":
            case "multiply":
                return new MathInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                    operation: operator,
                });
            case "push":
                return new PushInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                });
            case "pop":
                return new PopInputField({
                    attachedTo,
                    attribute,
                    inputValue: value,
                });
            default:
                throw new Error(`Unsupported update operator ${operator} on field ${attribute.name} `);
        }
    }

    private createNestedUpdateOperation({
        nestedEntity,
        nestedRelationship,
        nestedUpdateInputItem,
        context,
        callbackBucket,
        operation,
        key,
    }: {
        nestedEntity: ConcreteEntityAdapter | InterfaceEntityAdapter;
        nestedRelationship: RelationshipAdapter;
        nestedUpdateInputItem: Record<string, any>;
        context: Neo4jGraphQLTranslationContext;
        callbackBucket: CallbackBucket;
        operation: UpdateOperation;
        key: string;
    }) {
        asArray(nestedUpdateInputItem).forEach((input) => {
            const edgeFields = input.edge ?? {};
            const nodeInputFields = input.node ?? {};

            const entityAndNodeInput: Array<[ConcreteEntityAdapter, Record<string, any>]> = [];

            if (isConcreteEntity(nestedEntity)) {
                entityAndNodeInput.push([nestedEntity, nodeInputFields]);
            } else {
                nestedEntity.concreteEntities.forEach((concreteEntity) => {
                    entityAndNodeInput.push([concreteEntity, nodeInputFields]);
                });
            }

            entityAndNodeInput.forEach(([concreteEntity, nodeInputFields]) => {
                const nestedUpdateOperation = new UpdateOperation({
                    target: concreteEntity,
                    relationship: nestedRelationship,
                    selectionPattern: new RelationshipSelectionPattern({
                        relationship: nestedRelationship,
                        targetOverride: concreteEntity,
                    }),
                });

                this.hydrateUpdateOperation({
                    target: concreteEntity,
                    relationship: nestedRelationship,
                    input: { node: nodeInputFields, edge: edgeFields },
                    update: nestedUpdateOperation,
                    callbackBucket,
                    context,
                    whereArgs: input.where ?? {},
                });

                const mutationOperationField = new MutationOperationField(nestedUpdateOperation, key);
                operation.addField(mutationOperationField);
            });
        });
    }
}
